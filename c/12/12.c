/*
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?

 */


#include <stdio.h>
#include <stdlib.h>

#include "../euler.c"

long triangular(n)
/*
    Returns triangular number n
 */
{
    int i;
    long sum=0;

    for ( i=1; i<=n; i++ ) {
       sum += i;
    }

    return sum;
}

int *list_factors(long int n)
/*
 Returns a pointer to an array of the factors of n.

 weed: could be made faster by capturing and using information about the other factor when a factor is discovered.  The existence of a factor implies a reciprocal.  If the factors are found in ascending order, the reciprocals will be found in descending order.  So the reciprocal of the lower factor can be added to the list of factors, and the search for factors re-capped at that reciprocal, as no further factors will be found that are greater than that reciprocal.  This would cut processing time for this function at least in half, as it would avoid re-discovering half of the factors, and would avoid checking many values that cannot possibly be factors.

 */
{
    int *factors = calloc(1000, sizeof(long int));
    long int i;
    int j=0;

    for ( i=1; i <= n/2; i++ ) {
        if ( n % i == 0 ) {
            factors[j++] = i;
        }
    }

    factors[j++] = n;
    factors[j] = -1;

    return factors;
}


int main ()
{
    /* various checks on functions written

    long int val;
    int i = 0;
    int *factors;
    int count;

    factors = list_factors(10);

    while ( ( val = factors[i++] ) != -1 ) {
        printf("%ld\n", val);
    }

    count = size_ry(factors);
    printf("%d\n", count);
    return 0;
     */

    int i = 1;
    int *factors;
    int factors_count, tri;

    factors = list_factors(1);

    while ( (factors_count = size_ry(factors)) != 500 ) {
        if ( factors_count % 50 == 0 ) {
            printf("tri: %d\n", tri);
            printf("factors: %d\n", factors_count);
        }
        tri = triangular(i++);
        factors = list_factors(tri);
    }

    printf("Answer: %d\n", tri);

}
