CHECK FOR PALINDROME

approaches:
1.  Convert integer to string, then inspect string using array methods?

2.  Break down integer into multiples of powers of ten
    - to get final integer:
        if less than 10:
            value is final integer
        if more than 10:
            divide by 10, remainder is integer
            OR
            modulo 10, remainder is integer

            these presume value is float, yes?

    - to get next integer:
        subtract final integer, divide by ten

        OR divide by ten, take integer

        continue processing until value is less than 10


pseudo code:

/* ------------------------------------------------------------------------ */
int *get_digits(int n)
/* 
    Returns array holding each digit of n
 */
{
    // declare pointer to array to hold digits -- size?

    // get final digit, put in array
    // remove final digit

    while ( n > 0 ) {
        digit_ry[d_ndx++] = get_final(n);
        n = strip_final(n);
    }

    // put -1 at end of ry

    // reverse digit_ry

    // return digit_ry
}

/* ------------------------------------------------------------------------ */
int *get_digits(int n)
/* 
    Returns array holding each digit of n
 */
{
    // declare pointer to array to hold digits -- size?

    // get final digit, put in array
    // remove final digit

    while ( n > 0 ) {
        digit_ry[d_ndx++] = get_final(n);
        n = strip_final(n);
    }

    // put -1 at end of ry

    // reverse digit_ry

    // return digit_ry
}

/* ------------------------------------------------------------------------ */
int get_final(float n)
/*
    Gets the final digit of n
 */
{
    return n % 10;
}

float strip_final(float n)
/*
    Removes the last digit from n
 */
{
    float stripped;
    if ( n < 10 ) {
        stripped = 0;
    } else {
        stripped = n -  get_final(n);
    }
    return stripped;
}

/* ------------------------------------------------------------------------ */
int is_palindrome(float n)
/*
    Returns whether n is palindromic
 */

    digit_ry = get_digits(n);
    ndigits = size(digit_ry);
    comp = ndigits + 1;
        /*
            if there are 7 digits in the number, we will compare 7 to 1, 6 to 2, 5 to 3, 4 to 4.  the sum of these pairs, 8, is the 'comp'.  until I get a better term.

            but if first index is 0, index of last of seven digits will be 6, comp should be 7?

         */

    int dr_ndx = 0;
    while ( ct >= ndigits / 2 && palindromic ) {    // no need to do these checks twice
        if digit_ry[ct] != digit_ry[comp - ct] {
            palindromic = FALSE;
        }
    }

    return palindromic;


/* ------------------------------------------------------------------------ */
int *get_palindromes(int d1, int d2)
/*
    Returns pointer to array of palindromes resulting from multiplication of all number of n1 digits by numbers of n2 digits
 */
{
    min1 = 10 ^ (d1 -1);
    max1 = 10 ^ d1 - 1;
    min2 = 10 ^ (d2 -1);
    max2 = 10 ^ d2 - 1;

    for ( val1 = min1; val1 <= max1; val++ ) {
        for ( val2 = min2; val2 <= max2; val++ ) {
            prod = val1 * val2;
            if is_palindrome(prod) {
                // put prod in array
            }
    }

    // sort array of palindromes
    // return array of palindromes
}


/* ------------------------------------------------------------------------ */
float largest_palindrome(int d1, int d2)
/*
    Returns largest palindrome that is product of numbers of d1 and d2 digits
 */
{
    // palindromes = get_palindromes(d1, d2);
    // max_palindrome = max(palindromes(d1, d2);
    return max_palindromes;
}

/* ------------------------------------------------------------------------ */
main ()
{
    max_palindrome = largest_palindrome(SEED1, SEED2);
    printf("%d\n", max_palindrome);
    return 0;   // what is the bash convention for successful program termination?


}

/* ------------------------------------------------------------------------ */

